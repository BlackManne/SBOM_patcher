{
  "No": "CVE-2023-50868",
  "patch_list": [
    {
      "patch_url": "https://github.com/PowerDNS/pdns/pull/13781",
      "service_name": "github_pull",
      "patch_detail": {
        "title": "rec: CVE-2023-50387 and CVE-2023-50868",
        "labels": [
          {
            "name": "rec",
            "description": null
          },
          {
            "name": "defect",
            "description": null
          }
        ],
        "created_time": "2024-02-13T12:01:15Z",
        "updated_time": "2024-02-13T12:49:05Z",
        "closed_time": "2024-02-13T12:49:02Z",
        "content": "Short description <!-- Write a small description of what this Pull Request fixes or provides, including the issue #s -->\nChecklist <!-- please indicate if any of these things are done/included with this Pull Request. Not all boxes need to be checked for the Pull Request to be accepted -->\nI have:\n- [X] read the [CONTRIBUTING.md](https://github.com/PowerDNS/pdns/blob/master/CONTRIBUTING.md) document\n- [ ] compiled this code\n- [ ] tested this code\n- [ ] included documentation (including possible behaviour changes)\n- [ ] documented the code\n- [ ] added or modified regression test(s)\n- [ ] added or modified unit test(s)\n- [ ] <!-- remove this line if your PR is against master --> checked that this code was merged to master\n",
        "comments": [
          {
            "type": "label",
            "content": "rec",
            "url": ""
          },
          {
            "type": "label",
            "content": "defect",
            "url": ""
          },
          {
            "type": "comment",
            "content": "## Pull Request Test Coverage Report for [Build 7886132845](https://coveralls.io/builds/65664946)\n\n\nDetails\n\n* **-96** of **820**   **(88.29%)**  changed or added relevant lines in **12** files are covered.\n* **43** unchanged lines in **7** files lost coverage.\n* Overall coverage increased (+**0.1%**) to **58.24%**\n\n---\n\n|  Changes Missing Coverage | Covered Lines | Changed/Added Lines | % |\n| :-----|--------------|--------|---: |\n| [pdns/recursordist/aggressive_nsec.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Faggressive_nsec.cc#L561) | 15 | 16 | 93.75%\n| [pdns/recursordist/syncres.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Fsyncres.cc#L3890) | 11 | 13 | 84.62%\n| [pdns/recursordist/test-syncres_cc.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Ftest-syncres_cc.cc#L355) | 20 | 22 | 90.91%\n| [pdns/recursordist/rec-zonetocache.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Frec-zonetocache.cc#L300) | 3 | 8 | 37.5%\n| [pdns/recursordist/rec-main.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Frec-main.cc#L1568) | 0 | 7 | 0.0%\n| [pdns/recursordist/test-syncres_cc4.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Ftest-syncres_cc4.cc#L1012) | 284 | 293 | 96.93%\n| [pdns/recursordist/test-syncres_cc5.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Ftest-syncres_cc5.cc#L1312) | 110 | 124 | 88.71%\n| [pdns/recursordist/pdns_recursor.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Fpdns_recursor.cc#L571) | 0 | 23 | 0.0%\n| [pdns/validate.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Fvalidate.cc#L179) | 103 | 136 | 75.74%\n<!-- | **Total:** | **724** | **820** | **88.29%** | -->\n\n|  Files with Coverage Reduction | New Missed Lines | % |\n| :-----|--------------|--: |\n| [pdns/dnsdistdist/dnsdist-backend.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Fdnsdistdist%2Fdnsdist-backend.cc#L703) | 1 | 66.73% |\n| [pdns/recursordist/pdns_recursor.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Fpdns_recursor.cc#L1475) | 1 | 0.0% |\n| [modules/lmdbbackend/lmdbbackend.cc](https://coveralls.io/builds/65664946/source?filename=modules%2Flmdbbackend%2Flmdbbackend.cc#L2178) | 2 | 72.35% |\n| [modules/godbcbackend/sodbc.cc](https://coveralls.io/builds/65664946/source?filename=modules%2Fgodbcbackend%2Fsodbc.cc#L387) | 4 | 70.8% |\n| [ext/luawrapper/include/LuaContext.hpp](https://coveralls.io/builds/65664946/source?filename=ext%2Fluawrapper%2Finclude%2FLuaContext.hpp#L1554) | 8 | 13.88% |\n| [pdns/recursordist/test-syncres_cc1.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Ftest-syncres_cc1.cc#L965) | 13 | 89.2% |\n| [pdns/recursordist/settings/cxxsettings-generated.cc](https://coveralls.io/builds/65664946/source?filename=pdns%2Frecursordist%2Fsettings%2Fcxxsettings-generated.cc#L409) | 14 | 91.56% |\n<!-- | **Total:** | **43** |  | -->\n\n|  Totals | [![Coverage Status](https://coveralls.io/builds/65664946/badge)](https://coveralls.io/builds/65664946) |\n| :-- | --: |\n| Change from base [Build 7885297830](https://coveralls.io/builds/65663295): |  0.1% |\n| Covered Lines: | 111410 |\n| Relevant Lines: | 158151 |\n\n---\n##ðŸ’›  - [Coveralls](https://coveralls.io)\n"
          }
        ]
      },
      "time": "2024-08-04 12:14:26"
    },
    {
      "patch_url": "https://github.com/NLnetLabs/unbound/commit/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c",
      "service_name": "github_commit",
      "patch_detail": {
        "message": "- Fix CVE-2023-50868, NSEC3 closest encloser proof can exhaust CPU.",
        "changes": {
          "total": 778,
          "additions": 611,
          "deletions": 167
        },
        "files": [
          {
            "filename": "services/cache/dns.c",
            "additions": 22,
            "deletions": 0,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/services%2Fcache%2Fdns.c",
            "diff": "@@ -690,6 +690,28 @@ tomsg(struct module_env* env, struct query_info* q, struct reply_info* r,\n \treturn msg;\n }\n \n+struct dns_msg*\n+dns_msg_deepcopy_region(struct dns_msg* origin, struct regional* region)\n+{\n+\tsize_t i;\n+\tstruct dns_msg* res = NULL;\n+\tres = gen_dns_msg(region, &origin->qinfo, origin->rep->rrset_count);\n+\tif(!res) return NULL;\n+\t*res->rep = *origin->rep;\n+\tif(origin->rep->reason_bogus_str) {\n+\t\tres->rep->reason_bogus_str = regional_strdup(region,\n+\t\t\torigin->rep->reason_bogus_str);\n+\t}\n+\tfor(i=0; i<res->rep->rrset_count; i++) {\n+\t\tres->rep->rrsets[i] = packed_rrset_copy_region(\n+\t\t\torigin->rep->rrsets[i], region, 0);\n+\t\tif(!res->rep->rrsets[i]) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\treturn res;\n+}\n+\n /** synthesize RRset-only response from cached RRset item */\n static struct dns_msg*\n rrset_msg(struct ub_packed_rrset_key* rrset, struct regional* region, "
          },
          {
            "filename": "services/cache/dns.h",
            "additions": 9,
            "deletions": 0,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/services%2Fcache%2Fdns.h",
            "diff": "@@ -164,6 +164,15 @@ struct dns_msg* tomsg(struct module_env* env, struct query_info* q,\n \tstruct reply_info* r, struct regional* region, time_t now,\n \tint allow_expired, struct regional* scratch);\n \n+/**\n+ * Deep copy a dns_msg to a region.\n+ * @param origin: the dns_msg to copy.\n+ * @param region: the region to copy all the data to.\n+ * @return the new dns_msg or NULL on malloc error.\n+ */\n+struct dns_msg* dns_msg_deepcopy_region(struct dns_msg* origin,\n+\tstruct regional* region);\n+\n /** \n  * Find cached message \n  * @param env: module environment with the DNS cache."
          },
          {
            "filename": "testcode/unitverify.c",
            "additions": 2,
            "deletions": 2,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/testcode%2Funitverify.c",
            "diff": "@@ -443,9 +443,9 @@ nsec3_hash_test_entry(struct entry* e, rbtree_type* ct,\n \n \tret = nsec3_hash_name(ct, region, buf, nsec3, 0, qname,\n \t\tqinfo.qname_len, &hash);\n-\tif(ret != 1) {\n+\tif(ret < 1) {\n \t\tprintf(\"Bad nsec3_hash_name retcode %d\\n\", ret);\n-\t\tunit_assert(ret == 1);\n+\t\tunit_assert(ret == 1 || ret == 2);\n \t}\n \tunit_assert(hash->dname && hash->hash && hash->hash_len &&\n \t\thash->b32 && hash->b32_len);"
          },
          {
            "filename": "testdata/val_nx_nsec3_collision.rpl",
            "additions": 3,
            "deletions": 0,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/testdata%2Fval_nx_nsec3_collision.rpl",
            "diff": "@@ -156,6 +156,9 @@ SECTION QUESTION\n www.example.com. IN A\n ENTRY_END\n \n+; Allow validation resuming for NSEC3 hash calculations\n+STEP 2 TIME_PASSES ELAPSE 0.05\n+\n ; recursion happens here.\n STEP 10 CHECK_ANSWER\n ENTRY_BEGIN"
          },
          {
            "filename": "util/fptr_wlist.c",
            "additions": 1,
            "deletions": 1,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/util%2Ffptr_wlist.c",
            "diff": "@@ -131,7 +131,7 @@ fptr_whitelist_comm_timer(void (*fptr)(void*))\n \telse if(fptr == &pending_udp_timer_delay_cb) return 1;\n \telse if(fptr == &worker_stat_timer_cb) return 1;\n \telse if(fptr == &worker_probe_timer_cb) return 1;\n-\telse if(fptr == &validate_msg_signatures_timer_cb) return 1;\n+\telse if(fptr == &validate_suspend_timer_cb) return 1;\n #ifdef UB_ON_WINDOWS\n \telse if(fptr == &wsvc_cron_cb) return 1;\n #endif"
          },
          {
            "filename": "validator/val_nsec3.c",
            "additions": 243,
            "deletions": 69,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/validator%2Fval_nsec3.c",
            "diff": "@@ -57,6 +57,19 @@\n /* we include nsec.h for the bitmap_has_type function */\n #include \"validator/val_nsec.h\"\n #include \"sldns/sbuffer.h\"\n+#include \"util/config_file.h\"\n+\n+/**\n+ * Max number of NSEC3 calculations at once, suspend query for later.\n+ * 8 is low enough and allows for cases where multiple proofs are needed.\n+ */\n+#define MAX_NSEC3_CALCULATIONS 8\n+/**\n+ * When all allowed NSEC3 calculations at once resulted in error treat as\n+ * bogus. NSEC3 hash errors are not cached and this helps breaks loops with\n+ * erroneous data.\n+ */\n+#define MAX_NSEC3_ERRORS -1\n \n /** \n  * This function we get from ldns-compat or from base system \n@@ -532,6 +545,17 @@ nsec3_hash_cmp(const void* c1, const void* c2)\n \treturn memcmp(s1, s2, s1len);\n }\n \n+int\n+nsec3_cache_table_init(struct nsec3_cache_table* ct, struct regional* region)\n+{\n+\tif(ct->ct) return 1;\n+\tct->ct = (rbtree_type*)regional_alloc(region, sizeof(*ct->ct));\n+\tif(!ct->ct) return 0;\n+\tct->region = region;\n+\trbtree_init(ct->ct, &nsec3_hash_cmp);\n+\treturn 1;\n+}\n+\n size_t\n nsec3_get_hashed(sldns_buffer* buf, uint8_t* nm, size_t nmlen, int algo, \n \tsize_t iter, uint8_t* salt, size_t saltlen, uint8_t* res, size_t max)\n@@ -646,7 +670,7 @@ nsec3_hash_name(rbtree_type* table, struct regional* region, sldns_buffer* buf,\n \tc = (struct nsec3_cached_hash*)rbtree_search(table, &looki);\n \tif(c) {\n \t\t*hash = c;\n-\t\treturn 1;\n+\t\treturn 2;\n \t}\n \t/* create a new entry */\n \tc = (struct nsec3_cached_hash*)regional_alloc(region, sizeof(*c));\n@@ -658,10 +682,10 @@ nsec3_hash_name(rbtree_type* table, struct regional* region, sldns_buffer* buf,\n \tc->dname_len = dname_len;\n \tr = nsec3_calc_hash(region, buf, c);\n \tif(r != 1)\n-\t\treturn r;\n+\t\treturn r;  /* returns -1 or 0 */\n \tr = nsec3_calc_b32(region, buf, c);\n \tif(r != 1)\n-\t\treturn r;\n+\t\treturn r;  /* returns 0 */\n #ifdef UNBOUND_DEBUG\n \tn =\n #else\n@@ -704,6 +728,7 @@ nsec3_hash_matches_owner(struct nsec3_filter* flt,\n \tstruct nsec3_cached_hash* hash, struct ub_packed_rrset_key* s)\n {\n \tuint8_t* nm = s->rk.dname;\n+\tif(!hash) return 0; /* please clang */\n \t/* compare, does hash of name based on params in this NSEC3\n \t * match the owner name of this NSEC3? \n \t * name must be: <hashlength>base32 . zone name \n@@ -730,34 +755,50 @@ nsec3_hash_matches_owner(struct nsec3_filter* flt,\n  * @param nmlen: length of name.\n  * @param rrset: nsec3 that matches is returned here.\n  * @param rr: rr number in nsec3 rrset that matches.\n+ * @param calculations: current hash calculations.\n  * @return true if a matching NSEC3 is found, false if not.\n  */\n static int\n find_matching_nsec3(struct module_env* env, struct nsec3_filter* flt,\n-\trbtree_type* ct, uint8_t* nm, size_t nmlen, \n-\tstruct ub_packed_rrset_key** rrset, int* rr)\n+\tstruct nsec3_cache_table* ct, uint8_t* nm, size_t nmlen,\n+\tstruct ub_packed_rrset_key** rrset, int* rr,\n+\tint* calculations)\n {\n \tsize_t i_rs;\n \tint i_rr;\n \tstruct ub_packed_rrset_key* s;\n \tstruct nsec3_cached_hash* hash = NULL;\n \tint r;\n+\tint calc_errors = 0;\n \n \t/* this loop skips other-zone and unknown NSEC3s, also non-NSEC3 RRs */\n \tfor(s=filter_first(flt, &i_rs, &i_rr); s; \n \t\ts=filter_next(flt, &i_rs, &i_rr)) {\n+\t\t/* check if we are allowed more calculations */\n+\t\tif(*calculations >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tif(calc_errors == *calculations) {\n+\t\t\t\t*calculations = MAX_NSEC3_ERRORS;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n \t\t/* get name hashed for this NSEC3 RR */\n-\t\tr = nsec3_hash_name(ct, env->scratch, env->scratch_buffer,\n+\t\tr = nsec3_hash_name(ct->ct, ct->region, env->scratch_buffer,\n \t\t\ts, i_rr, nm, nmlen, &hash);\n \t\tif(r == 0) {\n \t\t\tlog_err(\"nsec3: malloc failure\");\n \t\t\tbreak; /* alloc failure */\n-\t\t} else if(r != 1)\n-\t\t\tcontinue; /* malformed NSEC3 */\n-\t\telse if(nsec3_hash_matches_owner(flt, hash, s)) {\n-\t\t\t*rrset = s; /* rrset with this name */\n-\t\t\t*rr = i_rr; /* matches hash with these parameters */\n-\t\t\treturn 1;\n+\t\t} else if(r < 0) {\n+\t\t\t/* malformed NSEC3 */\n+\t\t\tcalc_errors++;\n+\t\t\t(*calculations)++;\n+\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tif(r == 1) (*calculations)++;\n+\t\t\tif(nsec3_hash_matches_owner(flt, hash, s)) {\n+\t\t\t\t*rrset = s; /* rrset with this name */\n+\t\t\t\t*rr = i_rr; /* matches hash with these parameters */\n+\t\t\t\treturn 1;\n+\t\t\t}\n \t\t}\n \t}\n \t*rrset = NULL;\n@@ -775,6 +816,7 @@ nsec3_covers(uint8_t* zone, struct nsec3_cached_hash* hash,\n \tif(!nsec3_get_nextowner(rrset, rr, &next, &nextlen))\n \t\treturn 0; /* malformed RR proves nothing */\n \n+\tif(!hash) return 0; /* please clang */\n \t/* check the owner name is a hashed value . apex\n \t * base32 encoded values must have equal length. \n \t * hash_value and next hash value must have equal length. */\n@@ -823,35 +865,51 @@ nsec3_covers(uint8_t* zone, struct nsec3_cached_hash* hash,\n  * @param nmlen: length of name.\n  * @param rrset: covering NSEC3 rrset is returned here.\n  * @param rr: rr of cover is returned here.\n+ * @param calculations: current hash calculations.\n  * @return true if a covering NSEC3 is found, false if not.\n  */\n static int\n find_covering_nsec3(struct module_env* env, struct nsec3_filter* flt,\n-        rbtree_type* ct, uint8_t* nm, size_t nmlen, \n-\tstruct ub_packed_rrset_key** rrset, int* rr)\n+\tstruct nsec3_cache_table* ct, uint8_t* nm, size_t nmlen,\n+\tstruct ub_packed_rrset_key** rrset, int* rr,\n+\tint* calculations)\n {\n \tsize_t i_rs;\n \tint i_rr;\n \tstruct ub_packed_rrset_key* s;\n \tstruct nsec3_cached_hash* hash = NULL;\n \tint r;\n+\tint calc_errors = 0;\n \n \t/* this loop skips other-zone and unknown NSEC3s, also non-NSEC3 RRs */\n \tfor(s=filter_first(flt, &i_rs, &i_rr); s; \n \t\ts=filter_next(flt, &i_rs, &i_rr)) {\n+\t\t/* check if we are allowed more calculations */\n+\t\tif(*calculations >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tif(calc_errors == *calculations) {\n+\t\t\t\t*calculations = MAX_NSEC3_ERRORS;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n \t\t/* get name hashed for this NSEC3 RR */\n-\t\tr = nsec3_hash_name(ct, env->scratch, env->scratch_buffer,\n+\t\tr = nsec3_hash_name(ct->ct, ct->region, env->scratch_buffer,\n \t\t\ts, i_rr, nm, nmlen, &hash);\n \t\tif(r == 0) {\n \t\t\tlog_err(\"nsec3: malloc failure\");\n \t\t\tbreak; /* alloc failure */\n-\t\t} else if(r != 1)\n-\t\t\tcontinue; /* malformed NSEC3 */\n-\t\telse if(nsec3_covers(flt->zone, hash, s, i_rr, \n-\t\t\tenv->scratch_buffer)) {\n-\t\t\t*rrset = s; /* rrset with this name */\n-\t\t\t*rr = i_rr; /* covers hash with these parameters */\n-\t\t\treturn 1;\n+\t\t} else if(r < 0) {\n+\t\t\t/* malformed NSEC3 */\n+\t\t\tcalc_errors++;\n+\t\t\t(*calculations)++;\n+\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tif(r == 1) (*calculations)++;\n+\t\t\tif(nsec3_covers(flt->zone, hash, s, i_rr,\n+\t\t\t\tenv->scratch_buffer)) {\n+\t\t\t\t*rrset = s; /* rrset with this name */\n+\t\t\t\t*rr = i_rr; /* covers hash with these parameters */\n+\t\t\t\treturn 1;\n+\t\t\t}\n \t\t}\n \t}\n \t*rrset = NULL;\n@@ -869,11 +927,13 @@ find_covering_nsec3(struct module_env* env, struct nsec3_filter* flt,\n  * @param ct: cached hashes table.\n  * @param qinfo: query that is verified for.\n  * @param ce: closest encloser information is returned in here.\n+ * @param calculations: current hash calculations.\n  * @return true if a closest encloser candidate is found, false if not.\n  */\n static int\n-nsec3_find_closest_encloser(struct module_env* env, struct nsec3_filter* flt, \n-\trbtree_type* ct, struct query_info* qinfo, struct ce_response* ce)\n+nsec3_find_closest_encloser(struct module_env* env, struct nsec3_filter* flt,\n+\tstruct nsec3_cache_table* ct, struct query_info* qinfo,\n+\tstruct ce_response* ce, int* calculations)\n {\n \tuint8_t* nm = qinfo->qname;\n \tsize_t nmlen = qinfo->qname_len;\n@@ -888,8 +948,12 @@ nsec3_find_closest_encloser(struct module_env* env, struct nsec3_filter* flt,\n \t * may be the case. */\n \n \twhile(dname_subdomain_c(nm, flt->zone)) {\n+\t\tif(*calculations >= MAX_NSEC3_CALCULATIONS ||\n+\t\t\t*calculations == MAX_NSEC3_ERRORS) {\n+\t\t\treturn 0;\n+\t\t}\n \t\tif(find_matching_nsec3(env, flt, ct, nm, nmlen, \n-\t\t\t&ce->ce_rrset, &ce->ce_rr)) {\n+\t\t\t&ce->ce_rrset, &ce->ce_rr, calculations)) {\n \t\t\tce->ce = nm;\n \t\t\tce->ce_len = nmlen;\n \t\t\treturn 1;\n@@ -933,22 +997,38 @@ next_closer(uint8_t* qname, size_t qnamelen, uint8_t* ce,\n  * \tIf set true, and the return value is true, then you can be \n  * \tcertain that the ce.nc_rrset and ce.nc_rr are set properly.\n  * @param ce: closest encloser information is returned in here.\n+ * @param calculations: pointer to the current NSEC3 hash calculations.\n  * @return bogus if no closest encloser could be proven.\n  * \tsecure if a closest encloser could be proven, ce is set.\n  * \tinsecure if the closest-encloser candidate turns out to prove\n  * \t\tthat an insecure delegation exists above the qname.\n+ *\tunchecked if no more hash calculations are allowed at this point.\n  */\n static enum sec_status\n-nsec3_prove_closest_encloser(struct module_env* env, struct nsec3_filter* flt, \n-\trbtree_type* ct, struct query_info* qinfo, int prove_does_not_exist,\n-\tstruct ce_response* ce)\n+nsec3_prove_closest_encloser(struct module_env* env, struct nsec3_filter* flt,\n+\tstruct nsec3_cache_table* ct, struct query_info* qinfo,\n+\tint prove_does_not_exist, struct ce_response* ce, int* calculations)\n {\n \tuint8_t* nc;\n \tsize_t nc_len;\n \t/* robust: clean out ce, in case it gets abused later */\n \tmemset(ce, 0, sizeof(*ce));\n \n-\tif(!nsec3_find_closest_encloser(env, flt, ct, qinfo, ce)) {\n+\tif(!nsec3_find_closest_encloser(env, flt, ct, qinfo, ce, calculations)) {\n+\t\tif(*calculations == MAX_NSEC3_ERRORS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3 proveClosestEncloser: could \"\n+\t\t\t\t\"not find a candidate for the closest \"\n+\t\t\t\t\"encloser; all attempted hash calculations \"\n+\t\t\t\t\"were erroneous; bogus\");\n+\t\t\treturn sec_status_bogus;\n+\t\t} else if(*calculations >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3 proveClosestEncloser: could \"\n+\t\t\t\t\"not find a candidate for the closest \"\n+\t\t\t\t\"encloser; reached MAX_NSEC3_CALCULATIONS \"\n+\t\t\t\t\"(%d); unchecked still\",\n+\t\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\t\treturn sec_status_unchecked;\n+\t\t}\n \t\tverbose(VERB_ALGO, \"nsec3 proveClosestEncloser: could \"\n \t\t\t\"not find a candidate for the closest encloser.\");\n \t\treturn sec_status_bogus;\n@@ -989,9 +1069,23 @@ nsec3_prove_closest_encloser(struct module_env* env, struct nsec3_filter* flt,\n \t/* Otherwise, we need to show that the next closer name is covered. */\n \tnext_closer(qinfo->qname, qinfo->qname_len, ce->ce, &nc, &nc_len);\n \tif(!find_covering_nsec3(env, flt, ct, nc, nc_len, \n-\t\t&ce->nc_rrset, &ce->nc_rr)) {\n+\t\t&ce->nc_rrset, &ce->nc_rr, calculations)) {\n+\t\tif(*calculations == MAX_NSEC3_ERRORS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3: Could not find proof that the \"\n+\t\t\t\t\"candidate encloser was the closest encloser; \"\n+\t\t\t\t\"all attempted hash calculations were \"\n+\t\t\t\t\"erroneous; bogus\");\n+\t\t\treturn sec_status_bogus;\n+\t\t} else if(*calculations >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3: Could not find proof that the \"\n+\t\t\t\t\"candidate encloser was the closest encloser; \"\n+\t\t\t\t\"reached MAX_NSEC3_CALCULATIONS (%d); \"\n+\t\t\t\t\"unchecked still\",\n+\t\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\t\treturn sec_status_unchecked;\n+\t\t}\n \t\tverbose(VERB_ALGO, \"nsec3: Could not find proof that the \"\n-\t\t          \"candidate encloser was the closest encloser\");\n+\t\t\t\"candidate encloser was the closest encloser\");\n \t\treturn sec_status_bogus;\n \t}\n \treturn sec_status_secure;\n@@ -1019,8 +1113,8 @@ nsec3_ce_wildcard(struct regional* region, uint8_t* ce, size_t celen,\n \n /** Do the name error proof */\n static enum sec_status\n-nsec3_do_prove_nameerror(struct module_env* env, struct nsec3_filter* flt, \n-\trbtree_type* ct, struct query_info* qinfo)\n+nsec3_do_prove_nameerror(struct module_env* env, struct nsec3_filter* flt,\n+\tstruct nsec3_cache_table* ct, struct query_info* qinfo, int* calc)\n {\n \tstruct ce_response ce;\n \tuint8_t* wc;\n@@ -1032,11 +1126,15 @@ nsec3_do_prove_nameerror(struct module_env* env, struct nsec3_filter* flt,\n \t/* First locate and prove the closest encloser to qname. We will \n \t * use the variant that fails if the closest encloser turns out \n \t * to be qname. */\n-\tsec = nsec3_prove_closest_encloser(env, flt, ct, qinfo, 1, &ce);\n+\tsec = nsec3_prove_closest_encloser(env, flt, ct, qinfo, 1, &ce, calc);\n \tif(sec != sec_status_secure) {\n \t\tif(sec == sec_status_bogus)\n \t\t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: failed \"\n \t\t\t\t\"to prove a closest encloser\");\n+\t\telse if(sec == sec_status_unchecked)\n+\t\t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: will \"\n+\t\t\t\t\"continue proving closest encloser after \"\n+\t\t\t\t\"suspend\");\n \t\telse \tverbose(VERB_ALGO, \"nsec3 nameerror proof: closest \"\n \t\t\t\t\"nsec3 is an insecure delegation\");\n \t\treturn sec;\n@@ -1046,9 +1144,27 @@ nsec3_do_prove_nameerror(struct module_env* env, struct nsec3_filter* flt,\n \t/* At this point, we know that qname does not exist. Now we need \n \t * to prove that the wildcard does not exist. */\n \tlog_assert(ce.ce);\n-\twc = nsec3_ce_wildcard(env->scratch, ce.ce, ce.ce_len, &wclen);\n-\tif(!wc || !find_covering_nsec3(env, flt, ct, wc, wclen, \n-\t\t&wc_rrset, &wc_rr)) {\n+\twc = nsec3_ce_wildcard(ct->region, ce.ce, ce.ce_len, &wclen);\n+\tif(!wc) {\n+\t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: could not prove \"\n+\t\t\t\"that the applicable wildcard did not exist.\");\n+\t\treturn sec_status_bogus;\n+\t}\n+\tif(!find_covering_nsec3(env, flt, ct, wc, wclen, &wc_rrset, &wc_rr, calc)) {\n+\t\tif(*calc == MAX_NSEC3_ERRORS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: could not prove \"\n+\t\t\t\t\"that the applicable wildcard did not exist; \"\n+\t\t\t\t\"all attempted hash calculations were \"\n+\t\t\t\t\"erroneous; bogus\");\n+\t\t\treturn sec_status_bogus;\n+\t\t} else if(*calc >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: could not prove \"\n+\t\t\t\t\"that the applicable wildcard did not exist; \"\n+\t\t\t\t\"reached MAX_NSEC3_CALCULATIONS (%d); \"\n+\t\t\t\t\"unchecked still\",\n+\t\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\t\treturn sec_status_unchecked;\n+\t\t}\n \t\tverbose(VERB_ALGO, \"nsec3 nameerror proof: could not prove \"\n \t\t\t\"that the applicable wildcard did not exist.\");\n \t\treturn sec_status_bogus;\n@@ -1064,22 +1180,21 @@ nsec3_do_prove_nameerror(struct module_env* env, struct nsec3_filter* flt,\n enum sec_status\n nsec3_prove_nameerror(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num,\n-\tstruct query_info* qinfo, struct key_entry_key* kkey)\n+\tstruct query_info* qinfo, struct key_entry_key* kkey,\n+\tstruct nsec3_cache_table* ct, int* calc)\n {\n-\trbtree_type ct;\n \tstruct nsec3_filter flt;\n \n \tif(!list || num == 0 || !kkey || !key_entry_isgood(kkey))\n \t\treturn sec_status_bogus; /* no valid NSEC3s, bogus */\n-\trbtree_init(&ct, &nsec3_hash_cmp); /* init names-to-hash cache */\n \tfilter_init(&flt, list, num, qinfo); /* init RR iterator */\n \tif(!flt.zone)\n \t\treturn sec_status_bogus; /* no RRs */\n \tif(nsec3_iteration_count_high(ve, &flt, kkey))\n \t\treturn sec_status_insecure; /* iteration count too high */\n \tlog_nametypeclass(VERB_ALGO, \"start nsec3 nameerror proof, zone\", \n \t\tflt.zone, 0, 0);\n-\treturn nsec3_do_prove_nameerror(env, &flt, &ct, qinfo);\n+\treturn nsec3_do_prove_nameerror(env, &flt, ct, qinfo, calc);\n }\n \n /* \n@@ -1089,8 +1204,9 @@ nsec3_prove_nameerror(struct module_env* env, struct val_env* ve,\n \n /** Do the nodata proof */\n static enum sec_status\n-nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt, \n-\trbtree_type* ct, struct query_info* qinfo)\n+nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n+\tstruct nsec3_cache_table* ct, struct query_info* qinfo,\n+\tint* calc)\n {\n \tstruct ce_response ce;\n \tuint8_t* wc;\n@@ -1100,7 +1216,7 @@ nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n \tenum sec_status sec;\n \n \tif(find_matching_nsec3(env, flt, ct, qinfo->qname, qinfo->qname_len, \n-\t\t&rrset, &rr)) {\n+\t\t&rrset, &rr, calc)) {\n \t\t/* cases 1 and 2 */\n \t\tif(nsec3_has_type(rrset, rr, qinfo->qtype)) {\n \t\t\tverbose(VERB_ALGO, \"proveNodata: Matching NSEC3 \"\n@@ -1144,11 +1260,23 @@ nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n \t\t}\n \t\treturn sec_status_secure;\n \t}\n+\tif(*calc == MAX_NSEC3_ERRORS) {\n+\t\tverbose(VERB_ALGO, \"proveNodata: all attempted hash \"\n+\t\t\t\"calculations were erroneous while finding a matching \"\n+\t\t\t\"NSEC3, bogus\");\n+\t\treturn sec_status_bogus;\n+\t} else if(*calc >= MAX_NSEC3_CALCULATIONS) {\n+\t\tverbose(VERB_ALGO, \"proveNodata: reached \"\n+\t\t\t\"MAX_NSEC3_CALCULATIONS (%d) while finding a \"\n+\t\t\t\"matching NSEC3; unchecked still\",\n+\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\treturn sec_status_unchecked;\n+\t}\n \n \t/* For cases 3 - 5, we need the proven closest encloser, and it \n \t * can't match qname. Although, at this point, we know that it \n \t * won't since we just checked that. */\n-\tsec = nsec3_prove_closest_encloser(env, flt, ct, qinfo, 1, &ce);\n+\tsec = nsec3_prove_closest_encloser(env, flt, ct, qinfo, 1, &ce, calc);\n \tif(sec == sec_status_bogus) {\n \t\tverbose(VERB_ALGO, \"proveNodata: did not match qname, \"\n \t\t          \"nor found a proven closest encloser.\");\n@@ -1157,14 +1285,17 @@ nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n \t\tverbose(VERB_ALGO, \"proveNodata: closest nsec3 is insecure \"\n \t\t          \"delegation.\");\n \t\treturn sec_status_insecure;\n+\t} else if(sec==sec_status_unchecked) {\n+\t\treturn sec_status_unchecked;\n \t}\n \n \t/* Case 3: removed */\n \n \t/* Case 4: */\n \tlog_assert(ce.ce);\n-\twc = nsec3_ce_wildcard(env->scratch, ce.ce, ce.ce_len, &wclen);\n-\tif(wc && find_matching_nsec3(env, flt, ct, wc, wclen, &rrset, &rr)) {\n+\twc = nsec3_ce_wildcard(ct->region, ce.ce, ce.ce_len, &wclen);\n+\tif(wc && find_matching_nsec3(env, flt, ct, wc, wclen, &rrset, &rr,\n+\t\tcalc)) {\n \t\t/* found wildcard */\n \t\tif(nsec3_has_type(rrset, rr, qinfo->qtype)) {\n \t\t\tverbose(VERB_ALGO, \"nsec3 nodata proof: matching \"\n@@ -1195,6 +1326,18 @@ nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n \t\t}\n \t\treturn sec_status_secure;\n \t}\n+\tif(*calc == MAX_NSEC3_ERRORS) {\n+\t\tverbose(VERB_ALGO, \"nsec3 nodata proof: all attempted hash \"\n+\t\t\t\"calculations were erroneous while matching \"\n+\t\t\t\"wildcard, bogus\");\n+\t\treturn sec_status_bogus;\n+\t} else if(*calc >= MAX_NSEC3_CALCULATIONS) {\n+\t\tverbose(VERB_ALGO, \"nsec3 nodata proof: reached \"\n+\t\t\t\"MAX_NSEC3_CALCULATIONS (%d) while matching \"\n+\t\t\t\"wildcard, unchecked still\",\n+\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\treturn sec_status_unchecked;\n+\t}\n \n \t/* Case 5: */\n \t/* Due to forwarders, cnames, and other collating effects, we\n@@ -1223,28 +1366,27 @@ nsec3_do_prove_nodata(struct module_env* env, struct nsec3_filter* flt,\n enum sec_status\n nsec3_prove_nodata(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num,\n-\tstruct query_info* qinfo, struct key_entry_key* kkey)\n+\tstruct query_info* qinfo, struct key_entry_key* kkey,\n+\tstruct nsec3_cache_table* ct, int* calc)\n {\n-\trbtree_type ct;\n \tstruct nsec3_filter flt;\n \n \tif(!list || num == 0 || !kkey || !key_entry_isgood(kkey))\n \t\treturn sec_status_bogus; /* no valid NSEC3s, bogus */\n-\trbtree_init(&ct, &nsec3_hash_cmp); /* init names-to-hash cache */\n \tfilter_init(&flt, list, num, qinfo); /* init RR iterator */\n \tif(!flt.zone)\n \t\treturn sec_status_bogus; /* no RRs */\n \tif(nsec3_iteration_count_high(ve, &flt, kkey))\n \t\treturn sec_status_insecure; /* iteration count too high */\n-\treturn nsec3_do_prove_nodata(env, &flt, &ct, qinfo);\n+\treturn nsec3_do_prove_nodata(env, &flt, ct, qinfo, calc);\n }\n \n enum sec_status\n nsec3_prove_wildcard(struct module_env* env, struct val_env* ve,\n         struct ub_packed_rrset_key** list, size_t num,\n-\tstruct query_info* qinfo, struct key_entry_key* kkey, uint8_t* wc)\n+\tstruct query_info* qinfo, struct key_entry_key* kkey, uint8_t* wc,\n+\tstruct nsec3_cache_table* ct, int* calc)\n {\n-\trbtree_type ct;\n \tstruct nsec3_filter flt;\n \tstruct ce_response ce;\n \tuint8_t* nc;\n@@ -1254,7 +1396,6 @@ nsec3_prove_wildcard(struct module_env* env, struct val_env* ve,\n \n \tif(!list || num == 0 || !kkey || !key_entry_isgood(kkey))\n \t\treturn sec_status_bogus; /* no valid NSEC3s, bogus */\n-\trbtree_init(&ct, &nsec3_hash_cmp); /* init names-to-hash cache */\n \tfilter_init(&flt, list, num, qinfo); /* init RR iterator */\n \tif(!flt.zone)\n \t\treturn sec_status_bogus; /* no RRs */\n@@ -1272,8 +1413,22 @@ nsec3_prove_wildcard(struct module_env* env, struct val_env* ve,\n \t/* Now we still need to prove that the original data did not exist.\n \t * Otherwise, we need to show that the next closer name is covered. */\n \tnext_closer(qinfo->qname, qinfo->qname_len, ce.ce, &nc, &nc_len);\n-\tif(!find_covering_nsec3(env, &flt, &ct, nc, nc_len, \n-\t\t&ce.nc_rrset, &ce.nc_rr)) {\n+\tif(!find_covering_nsec3(env, &flt, ct, nc, nc_len,\n+\t\t&ce.nc_rrset, &ce.nc_rr, calc)) {\n+\t\tif(*calc == MAX_NSEC3_ERRORS) {\n+\t\t\tverbose(VERB_ALGO, \"proveWildcard: did not find a \"\n+\t\t\t\t\"covering NSEC3 that covered the next closer \"\n+\t\t\t\t\"name; all attempted hash calculations were \"\n+\t\t\t\t\"erroneous; bogus\");\n+\t\t\treturn sec_status_bogus;\n+\t\t} else if(*calc >= MAX_NSEC3_CALCULATIONS) {\n+\t\t\tverbose(VERB_ALGO, \"proveWildcard: did not find a \"\n+\t\t\t\t\"covering NSEC3 that covered the next closer \"\n+\t\t\t\t\"name; reached MAX_NSEC3_CALCULATIONS \"\n+\t\t\t\t\"(%d); unchecked still\",\n+\t\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\t\treturn sec_status_unchecked;\n+\t\t}\n \t\tverbose(VERB_ALGO, \"proveWildcard: did not find a covering \"\n \t\t\t\"NSEC3 that covered the next closer name.\");\n \t\treturn sec_status_bogus;\n@@ -1320,13 +1475,16 @@ enum sec_status\n nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num,\n \tstruct query_info* qinfo, struct key_entry_key* kkey, char** reason,\n-\tsldns_ede_code* reason_bogus, struct module_qstate* qstate)\n+\tsldns_ede_code* reason_bogus, struct module_qstate* qstate,\n+\tstruct nsec3_cache_table* ct)\n {\n-\trbtree_type ct;\n \tstruct nsec3_filter flt;\n \tstruct ce_response ce;\n \tstruct ub_packed_rrset_key* rrset;\n \tint rr;\n+\tint calc = 0;\n+\tenum sec_status sec;\n+\n \tlog_assert(qinfo->qtype == LDNS_RR_TYPE_DS);\n \n \tif(!list || num == 0 || !kkey || !key_entry_isgood(kkey)) {\n@@ -1337,7 +1495,6 @@ nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \t\t*reason = \"not all NSEC3 records secure\";\n \t\treturn sec_status_bogus; /* not all NSEC3 records secure */\n \t}\n-\trbtree_init(&ct, &nsec3_hash_cmp); /* init names-to-hash cache */\n \tfilter_init(&flt, list, num, qinfo); /* init RR iterator */\n \tif(!flt.zone) {\n \t\t*reason = \"no NSEC3 records\";\n@@ -1348,8 +1505,8 @@ nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \n \t/* Look for a matching NSEC3 to qname -- this is the normal \n \t * NODATA case. */\n-\tif(find_matching_nsec3(env, &flt, &ct, qinfo->qname, qinfo->qname_len, \n-\t\t&rrset, &rr)) {\n+\tif(find_matching_nsec3(env, &flt, ct, qinfo->qname, qinfo->qname_len,\n+\t\t&rrset, &rr, &calc)) {\n \t\t/* If the matching NSEC3 has the SOA bit set, it is from \n \t\t * the wrong zone (the child instead of the parent). If \n \t\t * it has the DS bit set, then we were lied to. */\n@@ -1372,10 +1529,24 @@ nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \t\t/* Otherwise, this proves no DS. */\n \t\treturn sec_status_secure;\n \t}\n+\tif(calc == MAX_NSEC3_ERRORS) {\n+\t\tverbose(VERB_ALGO, \"nsec3 provenods: all attempted hash \"\n+\t\t\t\"calculations were erroneous while finding a matching \"\n+\t\t\t\"NSEC3, bogus\");\n+\t\treturn sec_status_bogus;\n+\t} else if(calc >= MAX_NSEC3_CALCULATIONS) {\n+\t\tverbose(VERB_ALGO, \"nsec3 provenods: reached \"\n+\t\t\t\"MAX_NSEC3_CALCULATIONS (%d) while finding a \"\n+\t\t\t\"matching NSEC3, unchecked still\",\n+\t\t\tMAX_NSEC3_CALCULATIONS);\n+\t\treturn sec_status_unchecked;\n+\t}\n \n \t/* Otherwise, we are probably in the opt-out case. */\n-\tif(nsec3_prove_closest_encloser(env, &flt, &ct, qinfo, 1, &ce)\n-\t\t!= sec_status_secure) {\n+\tsec = nsec3_prove_closest_encloser(env, &flt, ct, qinfo, 1, &ce, &calc);\n+\tif(sec == sec_status_unchecked) {\n+\t\treturn sec_status_unchecked;\n+\t} else if(sec != sec_status_secure) {\n \t\t/* an insecure delegation *above* the qname does not prove\n \t\t * anything about this qname exactly, and bogus is bogus */\n \t\tverbose(VERB_ALGO, \"nsec3 provenods: did not match qname, \"\n@@ -1409,17 +1580,16 @@ nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \n enum sec_status\n nsec3_prove_nxornodata(struct module_env* env, struct val_env* ve,\n-\tstruct ub_packed_rrset_key** list, size_t num, \n-\tstruct query_info* qinfo, struct key_entry_key* kkey, int* nodata)\n+\tstruct ub_packed_rrset_key** list, size_t num,\n+\tstruct query_info* qinfo, struct key_entry_key* kkey, int* nodata,\n+\tstruct  nsec3_cache_table* ct, int* calc)\n {\n \tenum sec_status sec, secnx;\n-\trbtree_type ct;\n \tstruct nsec3_filter flt;\n \t*nodata = 0;\n \n \tif(!list || num == 0 || !kkey || !key_entry_isgood(kkey))\n \t\treturn sec_status_bogus; /* no valid NSEC3s, bogus */\n-\trbtree_init(&ct, &nsec3_hash_cmp); /* init names-to-hash cache */\n \tfilter_init(&flt, list, num, qinfo); /* init RR iterator */\n \tif(!flt.zone)\n \t\treturn sec_status_bogus; /* no RRs */\n@@ -1429,16 +1599,20 @@ nsec3_prove_nxornodata(struct module_env* env, struct val_env* ve,\n \t/* try nxdomain and nodata after another, while keeping the\n \t * hash cache intact */\n \n-\tsecnx = nsec3_do_prove_nameerror(env, &flt, &ct, qinfo);\n+\tsecnx = nsec3_do_prove_nameerror(env, &flt, ct, qinfo, calc);\n \tif(secnx==sec_status_secure)\n \t\treturn sec_status_secure;\n-\tsec = nsec3_do_prove_nodata(env, &flt, &ct, qinfo);\n+\telse if(secnx == sec_status_unchecked)\n+\t\treturn sec_status_unchecked;\n+\tsec = nsec3_do_prove_nodata(env, &flt, ct, qinfo, calc);\n \tif(sec==sec_status_secure) {\n \t\t*nodata = 1;\n \t} else if(sec == sec_status_insecure) {\n \t\t*nodata = 1;\n \t} else if(secnx == sec_status_insecure) {\n \t\tsec = sec_status_insecure;\n+\t} else if(sec == sec_status_unchecked) {\n+\t\treturn sec_status_unchecked;\n \t}\n \treturn sec;\n }"
          },
          {
            "filename": "validator/val_nsec3.h",
            "additions": 48,
            "deletions": 12,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/validator%2Fval_nsec3.h",
            "diff": "@@ -98,6 +98,15 @@ struct sldns_buffer;\n /** The SHA1 hash algorithm for NSEC3 */\n #define NSEC3_HASH_SHA1\t0x01\n \n+/**\n+* Cache table for NSEC3 hashes.\n+* It keeps a *pointer* to the region its items are allocated.\n+*/\n+struct nsec3_cache_table {\n+\trbtree_type* ct;\n+\tstruct regional* region;\n+};\n+\n /**\n  * Determine if the set of NSEC3 records provided with a response prove NAME\n  * ERROR. This means that the NSEC3s prove a) the closest encloser exists,\n@@ -110,14 +119,18 @@ struct sldns_buffer;\n  * @param num: number of RRsets in the array to examine.\n  * @param qinfo: query that is verified for.\n  * @param kkey: key entry that signed the NSEC3s.\n+ * @param ct: cached hashes table.\n+ * @param calc: current hash calculations.\n  * @return:\n  * \tsec_status SECURE of the Name Error is proven by the NSEC3 RRs, \n- * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored.\n+ * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored,\n+ * \tUNCHECKED if no more hash calculations are allowed at this point.\n  */\n enum sec_status\n nsec3_prove_nameerror(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num, \n-\tstruct query_info* qinfo, struct key_entry_key* kkey);\n+\tstruct query_info* qinfo, struct key_entry_key* kkey,\n+\tstruct nsec3_cache_table* ct, int* calc);\n \n /**\n  * Determine if the NSEC3s provided in a response prove the NOERROR/NODATA\n@@ -144,15 +157,18 @@ nsec3_prove_nameerror(struct module_env* env, struct val_env* ve,\n  * @param num: number of RRsets in the array to examine.\n  * @param qinfo: query that is verified for.\n  * @param kkey: key entry that signed the NSEC3s.\n+ * @param ct: cached hashes table.\n+ * @param calc: current hash calculations.\n  * @return:\n  * \tsec_status SECURE of the proposition is proven by the NSEC3 RRs, \n- * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored.\n+ * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored,\n+ * \tUNCHECKED if no more hash calculations are allowed at this point.\n  */\n enum sec_status\n nsec3_prove_nodata(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num, \n-\tstruct query_info* qinfo, struct key_entry_key* kkey);\n-\n+\tstruct query_info* qinfo, struct key_entry_key* kkey,\n+\tstruct nsec3_cache_table* ct, int* calc);\n \n /**\n  * Prove that a positive wildcard match was appropriate (no direct match\n@@ -166,14 +182,18 @@ nsec3_prove_nodata(struct module_env* env, struct val_env* ve,\n  * @param kkey: key entry that signed the NSEC3s.\n  * @param wc: The purported wildcard that matched. This is the wildcard name\n  * \tas *.wildcard.name., with the *. label already removed.\n+ * @param ct: cached hashes table.\n+ * @param calc: current hash calculations.\n  * @return:\n  * \tsec_status SECURE of the proposition is proven by the NSEC3 RRs, \n- * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored.\n+ * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored,\n+ * \tUNCHECKED if no more hash calculations are allowed at this point.\n  */\n enum sec_status\n nsec3_prove_wildcard(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num, \n-\tstruct query_info* qinfo, struct key_entry_key* kkey, uint8_t* wc);\n+\tstruct query_info* qinfo, struct key_entry_key* kkey, uint8_t* wc,\n+\tstruct nsec3_cache_table* ct, int* calc);\n \n /**\n  * Prove that a DS response either had no DS, or wasn't a delegation point.\n@@ -189,17 +209,20 @@ nsec3_prove_wildcard(struct module_env* env, struct val_env* ve,\n  * @param reason: string for bogus result.\n  * @param reason_bogus: EDE (RFC8914) code paired with the reason of failure.\n  * @param qstate: qstate with region.\n+ * @param ct: cached hashes table.\n  * @return:\n  * \tsec_status SECURE of the proposition is proven by the NSEC3 RRs, \n  * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored.\n  * \tor if there was no DS in an insecure (i.e., opt-in) way,\n- * \tINDETERMINATE if it was clear that this wasn't a delegation point.\n+ * \tINDETERMINATE if it was clear that this wasn't a delegation point,\n+ * \tUNCHECKED if no more hash calculations are allowed at this point.\n  */\n enum sec_status\n nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num, \n \tstruct query_info* qinfo, struct key_entry_key* kkey, char** reason,\n-\tsldns_ede_code* reason_bogus, struct module_qstate* qstate);\n+\tsldns_ede_code* reason_bogus, struct module_qstate* qstate,\n+\tstruct nsec3_cache_table* ct);\n \n /**\n  * Prove NXDOMAIN or NODATA.\n@@ -212,14 +235,18 @@ nsec3_prove_nods(struct module_env* env, struct val_env* ve,\n  * @param kkey: key entry that signed the NSEC3s.\n  * @param nodata: if return value is secure, this indicates if nodata or\n  * \tnxdomain was proven.\n+ * @param ct: cached hashes table.\n+ * @param calc: current hash calculations.\n  * @return:\n  * \tsec_status SECURE of the proposition is proven by the NSEC3 RRs, \n- * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored.\n+ * \tBOGUS if not, INSECURE if all of the NSEC3s could be validly ignored,\n+ * \tUNCHECKED if no more hash calculations are allowed at this point.\n  */\n enum sec_status\n nsec3_prove_nxornodata(struct module_env* env, struct val_env* ve,\n \tstruct ub_packed_rrset_key** list, size_t num, \n-\tstruct query_info* qinfo, struct key_entry_key* kkey, int* nodata);\n+\tstruct query_info* qinfo, struct key_entry_key* kkey, int* nodata,\n+\tstruct nsec3_cache_table* ct, int* calc);\n \n /**\n  * The NSEC3 hash result storage.\n@@ -256,6 +283,14 @@ struct nsec3_cached_hash {\n  */\n int nsec3_hash_cmp(const void* c1, const void* c2);\n \n+/**\n+ * Initialise the NSEC3 cache table.\n+ * @param ct: the nsec3 cache table.\n+ * @param region: the region where allocations for the table will happen.\n+ * @return true on success, false on malloc error.\n+ */\n+int nsec3_cache_table_init(struct nsec3_cache_table* ct, struct regional* region);\n+\n /**\n  * Obtain the hash of an owner name.\n  * Used internally by the nsec3 proof functions in this file.\n@@ -272,7 +307,8 @@ int nsec3_hash_cmp(const void* c1, const void* c2);\n  * @param dname_len: the length of the name.\n  * @param hash: the hash node is returned on success.\n  * @return:\n- * \t1 on success, either from cache or newly hashed hash is returned.\n+ * \t2 on success, hash from cache is returned.\n+ * \t1 on success, newly computed hash is returned.\n  * \t0 on a malloc failure.\n  * \t-1 if the NSEC3 rr was badly formatted (i.e. formerr).\n  */"
          },
          {
            "filename": "validator/validator.c",
            "additions": 274,
            "deletions": 79,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/validator%2Fvalidator.c",
            "diff": "@@ -72,7 +72,7 @@\n /* forward decl for cache response and normal super inform calls of a DS */\n static void process_ds_response(struct module_qstate* qstate, \n \tstruct val_qstate* vq, int id, int rcode, struct dns_msg* msg, \n-\tstruct query_info* qinfo, struct sock_list* origin);\n+\tstruct query_info* qinfo, struct sock_list* origin, int* suspend);\n \n \n /* Updates the suplied EDE (RFC8914) code selectively so we don't lose\n@@ -304,10 +304,10 @@ val_restart(struct val_qstate* vq)\n \tstruct comm_timer* temp_timer;\n \tint restart_count;\n \tif(!vq) return;\n-\ttemp_timer = vq->msg_signatures_timer;\n+\ttemp_timer = vq->suspend_timer;\n \trestart_count = vq->restart_count+1;\n \tmemset(vq, 0, sizeof(*vq));\n-\tvq->msg_signatures_timer = temp_timer;\n+\tvq->suspend_timer = temp_timer;\n \tvq->restart_count = restart_count;\n \tvq->state = VAL_INIT_STATE;\n }\n@@ -625,7 +625,7 @@ prime_trust_anchor(struct module_qstate* qstate, struct val_qstate* vq,\n  * @param chase_reply: answer to validate.\n  * @param key_entry: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n- * @param suspend: returned true if the task takes to long and needs to\n+ * @param suspend: returned true if the task takes too long and needs to\n  * \tsuspend to continue the effort later.\n  * @return false if any of the rrsets in the an or ns sections of the message \n  * \tfail to verify. The message is then set to bogus.\n@@ -789,37 +789,38 @@ validate_msg_signatures(struct module_qstate* qstate, struct val_qstate* vq,\n }\n \n void\n-validate_msg_signatures_timer_cb(void* arg)\n+validate_suspend_timer_cb(void* arg)\n {\n \tstruct module_qstate* qstate = (struct module_qstate*)arg;\n-\tverbose(VERB_ALGO, \"validate_msg_signatures timer, continue\");\n+\tverbose(VERB_ALGO, \"validate_suspend timer, continue\");\n \tmesh_run(qstate->env->mesh, qstate->mesh_info, module_event_pass,\n \t\tNULL);\n }\n \n /** Setup timer to continue validation of msg signatures later */\n static int\n-validate_msg_signatures_setup_timer(struct module_qstate* qstate,\n-\tstruct val_qstate* vq, int id)\n+validate_suspend_setup_timer(struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int id, enum val_state resume_state)\n {\n \tstruct timeval tv;\n \tint usec, slack, base;\n \tif(vq->suspend_count >= MAX_VALIDATION_SUSPENDS) {\n-\t\tverbose(VERB_ALGO, \"validate_msg_signatures_setup_timer: \"\n+\t\tverbose(VERB_ALGO, \"validate_suspend timer: \"\n \t\t\t\"reached MAX_VALIDATION_SUSPENDS (%d); error out\",\n \t\t\tMAX_VALIDATION_SUSPENDS);\n \t\terrinf(qstate, \"max validation suspends reached, \"\n \t\t\t\"too many RRSIG validations\");\n \t\treturn 0;\n \t}\n-\tvq->state = VAL_VALIDATE_STATE;\n+\tverbose(VERB_ALGO, \"validate_suspend timer, set for suspend\");\n+\tvq->state = resume_state;\n \tqstate->ext_state[id] = module_wait_reply;\n-\tif(!vq->msg_signatures_timer) {\n-\t\tvq->msg_signatures_timer = comm_timer_create(\n+\tif(!vq->suspend_timer) {\n+\t\tvq->suspend_timer = comm_timer_create(\n \t\t\tqstate->env->worker_base,\n-\t\t\tvalidate_msg_signatures_timer_cb, qstate);\n-\t\tif(!vq->msg_signatures_timer) {\n-\t\t\tlog_err(\"validate_msg_signatures_setup_timer: \"\n+\t\t\tvalidate_suspend_timer_cb, qstate);\n+\t\tif(!vq->suspend_timer) {\n+\t\t\tlog_err(\"validate_suspend_setup_timer: \"\n \t\t\t\t\"out of memory for comm_timer_create\");\n \t\t\treturn 0;\n \t\t}\n@@ -850,7 +851,7 @@ validate_msg_signatures_setup_timer(struct module_qstate* qstate,\n \ttv.tv_usec = (usec % 1000000);\n \ttv.tv_sec = (usec / 1000000);\n \tvq->suspend_count ++;\n-\tcomm_timer_set(vq->msg_signatures_timer, &tv);\n+\tcomm_timer_set(vq->suspend_timer, &tv);\n \treturn 1;\n }\n \n@@ -952,11 +953,17 @@ remove_spurious_authority(struct reply_info* chase_reply,\n  * @param chase_reply: answer to that query to validate.\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_positive_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey)\n+\tstruct key_entry_key* kkey, struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int* nsec3_calculations, int* suspend)\n {\n \tuint8_t* wc = NULL;\n \tsize_t wl;\n@@ -965,6 +972,7 @@ validate_positive_response(struct module_env* env, struct val_env* ve,\n \tint nsec3s_seen = 0;\n \tsize_t i;\n \tstruct ub_packed_rrset_key* s;\n+\t*suspend = 0;\n \n \t/* validate the ANSWER section - this will be the answer itself */\n \tfor(i=0; i<chase_reply->an_numrrsets; i++) {\n@@ -1016,17 +1024,23 @@ validate_positive_response(struct module_env* env, struct val_env* ve,\n \t/* If this was a positive wildcard response that we haven't already\n \t * proven, and we have NSEC3 records, try to prove it using the NSEC3\n \t * records. */\n-\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen) {\n-\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve, \n+\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n+\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve,\n \t\t\tchase_reply->rrsets+chase_reply->an_numrrsets,\n-\t\t\tchase_reply->ns_numrrsets, qchase, kkey, wc);\n+\t\t\tchase_reply->ns_numrrsets, qchase, kkey, wc,\n+\t\t\t&vq->nsec3_cache_table, nsec3_calculations);\n \t\tif(sec == sec_status_insecure) {\n \t\t\tverbose(VERB_ALGO, \"Positive wildcard response is \"\n \t\t\t\t\"insecure\");\n \t\t\tchase_reply->security = sec_status_insecure;\n \t\t\treturn;\n-\t\t} else if(sec == sec_status_secure)\n+\t\t} else if(sec == sec_status_secure) {\n \t\t\twc_NSEC_ok = 1;\n+\t\t} else if(sec == sec_status_unchecked) {\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\t}\n \t}\n \n \t/* If after all this, we still haven't proven the positive wildcard\n@@ -1058,11 +1072,17 @@ validate_positive_response(struct module_env* env, struct val_env* ve,\n  * @param chase_reply: answer to that query to validate.\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_nodata_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey)\n+\tstruct key_entry_key* kkey, struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int* nsec3_calculations, int* suspend)\n {\n \t/* Since we are here, there must be nothing in the ANSWER section to\n \t * validate. */\n@@ -1079,6 +1099,7 @@ validate_nodata_response(struct module_env* env, struct val_env* ve,\n \tint nsec3s_seen = 0; /* nsec3s seen */\n \tstruct ub_packed_rrset_key* s; \n \tsize_t i;\n+\t*suspend = 0;\n \n \tfor(i=chase_reply->an_numrrsets; i<chase_reply->an_numrrsets+\n \t\tchase_reply->ns_numrrsets; i++) {\n@@ -1117,16 +1138,23 @@ validate_nodata_response(struct module_env* env, struct val_env* ve,\n \t\t}\n \t}\n \t\n-\tif(!has_valid_nsec && nsec3s_seen) {\n+\tif(!has_valid_nsec && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n \t\tenum sec_status sec = nsec3_prove_nodata(env, ve, \n \t\t\tchase_reply->rrsets+chase_reply->an_numrrsets,\n-\t\t\tchase_reply->ns_numrrsets, qchase, kkey);\n+\t\t\tchase_reply->ns_numrrsets, qchase, kkey,\n+\t\t\t&vq->nsec3_cache_table, nsec3_calculations);\n \t\tif(sec == sec_status_insecure) {\n \t\t\tverbose(VERB_ALGO, \"NODATA response is insecure\");\n \t\t\tchase_reply->security = sec_status_insecure;\n \t\t\treturn;\n-\t\t} else if(sec == sec_status_secure)\n+\t\t} else if(sec == sec_status_secure) {\n \t\t\thas_valid_nsec = 1;\n+\t\t} else if(sec == sec_status_unchecked) {\n+\t\t\t/* check is incomplete; suspend */\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\t}\n \t}\n \n \tif(!has_valid_nsec) {\n@@ -1158,11 +1186,18 @@ validate_nodata_response(struct module_env* env, struct val_env* ve,\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n  * @param rcode: adjusted RCODE, in case of RCODE/proof mismatch leniency.\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_nameerror_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey, int* rcode)\n+\tstruct key_entry_key* kkey, int* rcode,\n+\tstruct module_qstate* qstate, struct val_qstate* vq,\n+\tint* nsec3_calculations, int* suspend)\n {\n \tint has_valid_nsec = 0;\n \tint has_valid_wnsec = 0;\n@@ -1172,6 +1207,7 @@ validate_nameerror_response(struct module_env* env, struct val_env* ve,\n \tuint8_t* ce;\n \tint ce_labs = 0;\n \tint prev_ce_labs = 0;\n+\t*suspend = 0;\n \n \tfor(i=chase_reply->an_numrrsets; i<chase_reply->an_numrrsets+\n \t\tchase_reply->ns_numrrsets; i++) {\n@@ -1201,13 +1237,18 @@ validate_nameerror_response(struct module_env* env, struct val_env* ve,\n \t\t\tnsec3s_seen = 1;\n \t}\n \n-\tif((!has_valid_nsec || !has_valid_wnsec) && nsec3s_seen) {\n+\tif((!has_valid_nsec || !has_valid_wnsec) && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n \t\t/* use NSEC3 proof, both answer and auth rrsets, in case\n \t\t * NSEC3s end up in the answer (due to qtype=NSEC3 or so) */\n \t\tchase_reply->security = nsec3_prove_nameerror(env, ve,\n \t\t\tchase_reply->rrsets, chase_reply->an_numrrsets+\n-\t\t\tchase_reply->ns_numrrsets, qchase, kkey);\n-\t\tif(chase_reply->security != sec_status_secure) {\n+\t\t\tchase_reply->ns_numrrsets, qchase, kkey,\n+\t\t\t&vq->nsec3_cache_table, nsec3_calculations);\n+\t\tif(chase_reply->security == sec_status_unchecked) {\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\t} else if(chase_reply->security != sec_status_secure) {\n \t\t\tverbose(VERB_QUERY, \"NameError response failed nsec, \"\n \t\t\t\t\"nsec3 proof was %s\", sec_status_to_string(\n \t\t\t\tchase_reply->security));\n@@ -1219,26 +1260,34 @@ validate_nameerror_response(struct module_env* env, struct val_env* ve,\n \n \t/* If the message fails to prove either condition, it is bogus. */\n \tif(!has_valid_nsec) {\n+\t\tvalidate_nodata_response(env, ve, qchase, chase_reply, kkey,\n+\t\t\tqstate, vq, nsec3_calculations, suspend);\n+\t\tif(*suspend) return;\n \t\tverbose(VERB_QUERY, \"NameError response has failed to prove: \"\n \t\t          \"qname does not exist\");\n-\t\tchase_reply->security = sec_status_bogus;\n-\t\tupdate_reason_bogus(chase_reply, LDNS_EDE_DNSSEC_BOGUS);\n \t\t/* Be lenient with RCODE in NSEC NameError responses */\n-\t\tvalidate_nodata_response(env, ve, qchase, chase_reply, kkey);\n-\t\tif (chase_reply->security == sec_status_secure)\n+\t\tif(chase_reply->security == sec_status_secure) {\n \t\t\t*rcode = LDNS_RCODE_NOERROR;\n+\t\t} else {\n+\t\t\tchase_reply->security = sec_status_bogus;\n+\t\t\tupdate_reason_bogus(chase_reply, LDNS_EDE_DNSSEC_BOGUS);\n+\t\t}\n \t\treturn;\n \t}\n \n \tif(!has_valid_wnsec) {\n+\t\tvalidate_nodata_response(env, ve, qchase, chase_reply, kkey,\n+\t\t\tqstate, vq, nsec3_calculations, suspend);\n+\t\tif(*suspend) return;\n \t\tverbose(VERB_QUERY, \"NameError response has failed to prove: \"\n \t\t          \"covering wildcard does not exist\");\n-\t\tchase_reply->security = sec_status_bogus;\n-\t\tupdate_reason_bogus(chase_reply, LDNS_EDE_DNSSEC_BOGUS);\n \t\t/* Be lenient with RCODE in NSEC NameError responses */\n-\t\tvalidate_nodata_response(env, ve, qchase, chase_reply, kkey);\n-\t\tif (chase_reply->security == sec_status_secure)\n+\t\tif (chase_reply->security == sec_status_secure) {\n \t\t\t*rcode = LDNS_RCODE_NOERROR;\n+\t\t} else {\n+\t\t\tchase_reply->security = sec_status_bogus;\n+\t\t\tupdate_reason_bogus(chase_reply, LDNS_EDE_DNSSEC_BOGUS);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -1298,11 +1347,17 @@ validate_referral_response(struct reply_info* chase_reply)\n  * @param chase_reply: answer to that query to validate.\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_any_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey)\n+\tstruct key_entry_key* kkey, struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int* nsec3_calculations, int* suspend)\n {\n \t/* all answer and auth rrsets already verified */\n \t/* but check if a wildcard response is given, then check NSEC/NSEC3\n@@ -1313,6 +1368,7 @@ validate_any_response(struct module_env* env, struct val_env* ve,\n \tint nsec3s_seen = 0;\n \tsize_t i;\n \tstruct ub_packed_rrset_key* s;\n+\t*suspend = 0;\n \n \tif(qchase->qtype != LDNS_RR_TYPE_ANY) {\n \t\tlog_err(\"internal error: ANY validation called for non-ANY\");\n@@ -1367,19 +1423,25 @@ validate_any_response(struct module_env* env, struct val_env* ve,\n \t/* If this was a positive wildcard response that we haven't already\n \t * proven, and we have NSEC3 records, try to prove it using the NSEC3\n \t * records. */\n-\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen) {\n+\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n \t\t/* look both in answer and auth section for NSEC3s */\n-\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve, \n+\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve,\n \t\t\tchase_reply->rrsets,\n-\t\t\tchase_reply->an_numrrsets+chase_reply->ns_numrrsets, \n-\t\t\tqchase, kkey, wc);\n+\t\t\tchase_reply->an_numrrsets+chase_reply->ns_numrrsets,\n+\t\t\tqchase, kkey, wc, &vq->nsec3_cache_table,\n+\t\t\tnsec3_calculations);\n \t\tif(sec == sec_status_insecure) {\n \t\t\tverbose(VERB_ALGO, \"Positive ANY wildcard response is \"\n \t\t\t\t\"insecure\");\n \t\t\tchase_reply->security = sec_status_insecure;\n \t\t\treturn;\n-\t\t} else if(sec == sec_status_secure)\n+\t\t} else if(sec == sec_status_secure) {\n \t\t\twc_NSEC_ok = 1;\n+\t\t} else if(sec == sec_status_unchecked) {\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\t}\n \t}\n \n \t/* If after all this, we still haven't proven the positive wildcard\n@@ -1412,18 +1474,25 @@ validate_any_response(struct module_env* env, struct val_env* ve,\n  * @param chase_reply: answer to that query to validate.\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_cname_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey)\n+\tstruct key_entry_key* kkey, struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int* nsec3_calculations, int* suspend)\n {\n \tuint8_t* wc = NULL;\n \tsize_t wl;\n \tint wc_NSEC_ok = 0;\n \tint nsec3s_seen = 0;\n \tsize_t i;\n \tstruct ub_packed_rrset_key* s;\n+\t*suspend = 0;\n \n \t/* validate the ANSWER section - this will be the CNAME (+DNAME) */\n \tfor(i=0; i<chase_reply->an_numrrsets; i++) {\n@@ -1488,17 +1557,23 @@ validate_cname_response(struct module_env* env, struct val_env* ve,\n \t/* If this was a positive wildcard response that we haven't already\n \t * proven, and we have NSEC3 records, try to prove it using the NSEC3\n \t * records. */\n-\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen) {\n-\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve, \n+\tif(wc != NULL && !wc_NSEC_ok && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n+\t\tenum sec_status sec = nsec3_prove_wildcard(env, ve,\n \t\t\tchase_reply->rrsets+chase_reply->an_numrrsets,\n-\t\t\tchase_reply->ns_numrrsets, qchase, kkey, wc);\n+\t\t\tchase_reply->ns_numrrsets, qchase, kkey, wc,\n+\t\t\t&vq->nsec3_cache_table, nsec3_calculations);\n \t\tif(sec == sec_status_insecure) {\n \t\t\tverbose(VERB_ALGO, \"wildcard CNAME response is \"\n \t\t\t\t\"insecure\");\n \t\t\tchase_reply->security = sec_status_insecure;\n \t\t\treturn;\n-\t\t} else if(sec == sec_status_secure)\n+\t\t} else if(sec == sec_status_secure) {\n \t\t\twc_NSEC_ok = 1;\n+\t\t} else if(sec == sec_status_unchecked) {\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\t}\n \t}\n \n \t/* If after all this, we still haven't proven the positive wildcard\n@@ -1529,11 +1604,17 @@ validate_cname_response(struct module_env* env, struct val_env* ve,\n  * @param chase_reply: answer to that query to validate.\n  * @param kkey: the key entry, which is trusted, and which matches\n  * \tthe signer of the answer. The key entry isgood().\n+ * @param qstate: query state for the region.\n+ * @param vq: validator state for the nsec3 cache table.\n+ * @param nsec3_calculations: current nsec3 hash calculations.\n+ * @param suspend: returned true if the task takes too long and needs to\n+ * \tsuspend to continue the effort later.\n  */\n static void\n validate_cname_noanswer_response(struct module_env* env, struct val_env* ve,\n \tstruct query_info* qchase, struct reply_info* chase_reply,\n-\tstruct key_entry_key* kkey)\n+\tstruct key_entry_key* kkey, struct module_qstate* qstate,\n+\tstruct val_qstate* vq, int* nsec3_calculations, int* suspend)\n {\n \tint nodata_valid_nsec = 0; /* If true, then NODATA has been proven.*/\n \tuint8_t* ce = NULL; /* for wildcard nodata responses. This is the \n@@ -1547,6 +1628,7 @@ validate_cname_noanswer_response(struct module_env* env, struct val_env* ve,\n \tuint8_t* nsec_ce; /* Used to find the NSEC with the longest ce */\n \tint ce_labs = 0;\n \tint prev_ce_labs = 0;\n+\t*suspend = 0;\n \n \t/* the AUTHORITY section */\n \tfor(i=chase_reply->an_numrrsets; i<chase_reply->an_numrrsets+\n@@ -1612,11 +1694,13 @@ validate_cname_noanswer_response(struct module_env* env, struct val_env* ve,\n \t\tupdate_reason_bogus(chase_reply, LDNS_EDE_DNSSEC_BOGUS);\n \t\treturn;\n \t}\n-\tif(!nodata_valid_nsec && !nxdomain_valid_nsec && nsec3s_seen) {\n+\tif(!nodata_valid_nsec && !nxdomain_valid_nsec && nsec3s_seen &&\n+\t\tnsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n \t\tint nodata;\n \t\tenum sec_status sec = nsec3_prove_nxornodata(env, ve, \n \t\t\tchase_reply->rrsets+chase_reply->an_numrrsets,\n-\t\t\tchase_reply->ns_numrrsets, qchase, kkey, &nodata);\n+\t\t\tchase_reply->ns_numrrsets, qchase, kkey, &nodata,\n+\t\t\t&vq->nsec3_cache_table, nsec3_calculations);\n \t\tif(sec == sec_status_insecure) {\n \t\t\tverbose(VERB_ALGO, \"CNAMEchain to noanswer response \"\n \t\t\t\t\"is insecure\");\n@@ -1626,6 +1710,9 @@ validate_cname_noanswer_response(struct module_env* env, struct val_env* ve,\n \t\t\tif(nodata)\n \t\t\t\tnodata_valid_nsec = 1;\n \t\t\telse\tnxdomain_valid_nsec = 1;\n+\t\t} else if(sec == sec_status_unchecked) {\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n \t\t}\n \t}\n \n@@ -1969,13 +2056,37 @@ processFindKey(struct module_qstate* qstate, struct val_qstate* vq, int id)\n \t\t * Uses negative cache for NSEC3 lookup of DS responses. */\n \t\t/* only if cache not blacklisted, of course */\n \t\tstruct dns_msg* msg;\n-\t\tif(!qstate->blacklist && !vq->chain_blacklist &&\n+\t\tint suspend;\n+\t\tif(vq->sub_ds_msg) {\n+\t\t\t/* We have a suspended DS reply from a sub-query;\n+\t\t\t * process it. */\n+\t\t\tverbose(VERB_ALGO, \"Process suspended sub DS response\");\n+\t\t\tmsg = vq->sub_ds_msg;\n+\t\t\tprocess_ds_response(qstate, vq, id, LDNS_RCODE_NOERROR,\n+\t\t\t\tmsg, &msg->qinfo, NULL, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\t/* we'll come back here later to continue */\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate, vq,\n+\t\t\t\t\tid, VAL_FINDKEY_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t\tvq->sub_ds_msg = NULL;\n+\t\t\treturn 1; /* continue processing ds-response results */\n+\t\t} else if(!qstate->blacklist && !vq->chain_blacklist &&\n \t\t\t(msg=val_find_DS(qstate->env, target_key_name, \n \t\t\ttarget_key_len, vq->qchase.qclass, qstate->region,\n \t\t\tvq->key_entry->name)) ) {\n \t\t\tverbose(VERB_ALGO, \"Process cached DS response\");\n \t\t\tprocess_ds_response(qstate, vq, id, LDNS_RCODE_NOERROR,\n-\t\t\t\tmsg, &msg->qinfo, NULL);\n+\t\t\t\tmsg, &msg->qinfo, NULL, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\t/* we'll come back here later to continue */\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate, vq,\n+\t\t\t\t\tid, VAL_FINDKEY_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\treturn 1; /* continue processing ds-response results */\n \t\t}\n \t\tif(!generate_request(qstate, id, target_key_name, \n@@ -2018,7 +2129,7 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \tstruct val_env* ve, int id)\n {\n \tenum val_classification subtype;\n-\tint rcode, suspend;\n+\tint rcode, suspend, nsec3_calculations = 0;\n \n \tif(!vq->key_entry) {\n \t\tverbose(VERB_ALGO, \"validate: no key entry, failed\");\n@@ -2078,8 +2189,8 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \tif(!validate_msg_signatures(qstate, vq, qstate->env, ve, &vq->qchase,\n \t\tvq->chase_reply, vq->key_entry, &suspend)) {\n \t\tif(suspend) {\n-\t\t\tif(!validate_msg_signatures_setup_timer(qstate, vq,\n-\t\t\t\tid))\n+\t\t\tif(!validate_suspend_setup_timer(qstate, vq,\n+\t\t\t\tid, VAL_VALIDATE_STATE))\n \t\t\t\treturn val_error(qstate, id);\n \t\t\treturn 0;\n \t\t}\n@@ -2111,7 +2222,14 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\tcase VAL_CLASS_POSITIVE:\n \t\t\tverbose(VERB_ALGO, \"Validating a positive response\");\n \t\t\tvalidate_positive_response(qstate->env, ve,\n-\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry);\n+\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry,\n+\t\t\t\tqstate, vq, &nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(positive): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2120,7 +2238,14 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\tcase VAL_CLASS_NODATA:\n \t\t\tverbose(VERB_ALGO, \"Validating a nodata response\");\n \t\t\tvalidate_nodata_response(qstate->env, ve,\n-\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry);\n+\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry,\n+\t\t\t\tqstate, vq, &nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(nodata): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2130,7 +2255,14 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\trcode = (int)FLAGS_GET_RCODE(vq->orig_msg->rep->flags);\n \t\t\tverbose(VERB_ALGO, \"Validating a nxdomain response\");\n \t\t\tvalidate_nameerror_response(qstate->env, ve, \n-\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry, &rcode);\n+\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry, &rcode,\n+\t\t\t\tqstate, vq, &nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(nxdomain): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2141,7 +2273,14 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\tcase VAL_CLASS_CNAME:\n \t\t\tverbose(VERB_ALGO, \"Validating a cname response\");\n \t\t\tvalidate_cname_response(qstate->env, ve,\n-\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry);\n+\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry,\n+\t\t\t\tqstate, vq, &nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(cname): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2151,7 +2290,14 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\tverbose(VERB_ALGO, \"Validating a cname noanswer \"\n \t\t\t\t\"response\");\n \t\t\tvalidate_cname_noanswer_response(qstate->env, ve,\n-\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry);\n+\t\t\t\t&vq->qchase, vq->chase_reply, vq->key_entry,\n+\t\t\t\tqstate, vq, &nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(cname_noanswer): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2168,8 +2314,15 @@ processValidate(struct module_qstate* qstate, struct val_qstate* vq,\n \t\tcase VAL_CLASS_ANY:\n \t\t\tverbose(VERB_ALGO, \"Validating a positive ANY \"\n \t\t\t\t\"response\");\n-\t\t\tvalidate_any_response(qstate->env, ve, &vq->qchase, \n-\t\t\t\tvq->chase_reply, vq->key_entry);\n+\t\t\tvalidate_any_response(qstate->env, ve, &vq->qchase,\n+\t\t\t\tvq->chase_reply, vq->key_entry, qstate, vq,\n+\t\t\t\t&nsec3_calculations, &suspend);\n+\t\t\tif(suspend) {\n+\t\t\t\tif(!validate_suspend_setup_timer(qstate,\n+\t\t\t\t\tvq, id, VAL_VALIDATE_STATE))\n+\t\t\t\t\treturn val_error(qstate, id);\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tverbose(VERB_DETAIL, \"validate(positive_any): %s\",\n \t\t\t  \tsec_status_to_string(\n \t\t\t\tvq->chase_reply->security));\n@@ -2611,7 +2764,10 @@ primeResponseToKE(struct ub_packed_rrset_key* dnskey_rrset,\n  *\tDS response indicated an end to secure space, is_good if the DS\n  *\tvalidated. It returns ke=NULL if the DS response indicated that the\n  *\trequest wasn't a delegation point.\n- * @return 0 on servfail error (malloc failure).\n+ * @return\n+ *\t0 on success,\n+ *\t1 on servfail error (malloc failure),\n+ *\t2 on NSEC3 suspend.\n  */\n static int\n ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n@@ -2671,15 +2827,15 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\t\tub_packed_rrset_ttl(ds),\n \t\t\t\tLDNS_EDE_UNSUPPORTED_DS_DIGEST, NULL,\n \t\t\t\t*qstate->env->now);\n-\t\t\treturn (*ke) != NULL;\n+\t\t\treturn (*ke) == NULL;\n \t\t}\n \n \t\t/* Otherwise, we return the positive response. */\n \t\tlog_query_info(VERB_DETAIL, \"validated DS\", qinfo);\n \t\t*ke = key_entry_create_rrset(qstate->region,\n \t\t\tqinfo->qname, qinfo->qname_len, qinfo->qclass, ds,\n \t\t\tNULL, LDNS_EDE_NONE, NULL, *qstate->env->now);\n-\t\treturn (*ke) != NULL;\n+\t\treturn (*ke) == NULL;\n \t} else if(subtype == VAL_CLASS_NODATA || \n \t\tsubtype == VAL_CLASS_NAMEERROR) {\n \t\t/* NODATA means that the qname exists, but that there was \n@@ -2713,12 +2869,12 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\t\t\tqinfo->qclass, proof_ttl,\n \t\t\t\t\tLDNS_EDE_NONE, NULL,\n \t\t\t\t\t*qstate->env->now);\n-\t\t\t\treturn (*ke) != NULL;\n+\t\t\t\treturn (*ke) == NULL;\n \t\t\tcase sec_status_insecure:\n \t\t\t\tverbose(VERB_DETAIL, \"NSEC RRset for the \"\n \t\t\t\t  \"referral proved not a delegation point\");\n \t\t\t\t*ke = NULL;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\tcase sec_status_bogus:\n \t\t\t\tverbose(VERB_DETAIL, \"NSEC RRset for the \"\n \t\t\t\t\t\"referral did not prove no DS.\");\n@@ -2730,10 +2886,17 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\t\tbreak;\n \t\t}\n \n+\t\tif(!nsec3_cache_table_init(&vq->nsec3_cache_table, qstate->region)) {\n+\t\t\tlog_err(\"malloc failure in ds_response_to_ke for \"\n+\t\t\t\t\"NSEC3 cache\");\n+\t\t\treason = \"malloc failure\";\n+\t\t\terrinf_ede(qstate, reason, 0);\n+\t\t\tgoto return_bogus;\n+\t\t}\n \t\tsec = nsec3_prove_nods(qstate->env, ve, \n \t\t\tmsg->rep->rrsets + msg->rep->an_numrrsets,\n \t\t\tmsg->rep->ns_numrrsets, qinfo, vq->key_entry, &reason,\n-\t\t\t&reason_bogus, qstate);\n+\t\t\t&reason_bogus, qstate, &vq->nsec3_cache_table);\n \t\tswitch(sec) {\n \t\t\tcase sec_status_insecure:\n \t\t\t\t/* case insecure also continues to unsigned\n@@ -2747,18 +2910,19 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\t\t\tqinfo->qclass, proof_ttl,\n \t\t\t\t\tLDNS_EDE_NONE, NULL,\n \t\t\t\t\t*qstate->env->now);\n-\t\t\t\treturn (*ke) != NULL;\n+\t\t\t\treturn (*ke) == NULL;\n \t\t\tcase sec_status_indeterminate:\n \t\t\t\tverbose(VERB_DETAIL, \"NSEC3s for the \"\n \t\t\t\t  \"referral proved no delegation\");\n \t\t\t\t*ke = NULL;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\tcase sec_status_bogus:\n \t\t\t\tverbose(VERB_DETAIL, \"NSEC3s for the \"\n \t\t\t\t\t\"referral did not prove no DS.\");\n \t\t\t\terrinf_ede(qstate, reason, reason_bogus);\n \t\t\t\tgoto return_bogus;\n \t\t\tcase sec_status_unchecked:\n+\t\t\t\treturn 2;\n \t\t\tdefault:\n \t\t\t\t/* NSEC3 proof did not work */\n \t\t\t\tbreak;\n@@ -2805,7 +2969,7 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t\t\t\t\"proof that DS does not exist\");\n \t\t\t/* and that it is not a referral point */\n \t\t\t*ke = NULL;\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\t}\n \t\terrinf(qstate, \"CNAME in DS response was not secure.\");\n \t\terrinf_ede(qstate, reason, reason_bogus);\n@@ -2829,7 +2993,7 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n \t*ke = key_entry_create_bad(qstate->region, qinfo->qname,\n \t\tqinfo->qname_len, qinfo->qclass, BOGUS_KEY_TTL,\n \t\treason_bogus, reason, *qstate->env->now);\n-\treturn (*ke) != NULL;\n+\treturn (*ke) == NULL;\n }\n \n /**\n@@ -2850,17 +3014,31 @@ ds_response_to_ke(struct module_qstate* qstate, struct val_qstate* vq,\n static void\n process_ds_response(struct module_qstate* qstate, struct val_qstate* vq,\n \tint id, int rcode, struct dns_msg* msg, struct query_info* qinfo,\n-\tstruct sock_list* origin)\n+\tstruct sock_list* origin, int* suspend)\n {\n \tstruct val_env* ve = (struct val_env*)qstate->env->modinfo[id];\n \tstruct key_entry_key* dske = NULL;\n \tuint8_t* olds = vq->empty_DS_name;\n+\tint ret;\n+\t*suspend = 0;\n \tvq->empty_DS_name = NULL;\n-\tif(!ds_response_to_ke(qstate, vq, id, rcode, msg, qinfo, &dske)) {\n+\tret = ds_response_to_ke(qstate, vq, id, rcode, msg, qinfo, &dske);\n+\tif(ret != 0) {\n+\t\tswitch(ret) {\n+\t\tcase 1:\n \t\t\tlog_err(\"malloc failure in process_ds_response\");\n \t\t\tvq->key_entry = NULL; /* make it error */\n \t\t\tvq->state = VAL_VALIDATE_STATE;\n \t\t\treturn;\n+\t\tcase 2:\n+\t\t\t*suspend = 1;\n+\t\t\treturn;\n+\t\tdefault:\n+\t\t\tlog_err(\"unhandled error value for ds_response_to_ke\");\n+\t\t\tvq->key_entry = NULL; /* make it error */\n+\t\t\tvq->state = VAL_VALIDATE_STATE;\n+\t\t\treturn;\n+\t\t}\n \t}\n \tif(dske == NULL) {\n \t\tvq->empty_DS_name = regional_alloc_init(qstate->region,\n@@ -3112,9 +3290,26 @@ val_inform_super(struct module_qstate* qstate, int id,\n \t\treturn;\n \t}\n \tif(qstate->qinfo.qtype == LDNS_RR_TYPE_DS) {\n+\t\tint suspend;\n \t\tprocess_ds_response(super, vq, id, qstate->return_rcode,\n-\t\t\tqstate->return_msg, &qstate->qinfo, \n-\t\t\tqstate->reply_origin);\n+\t\t\tqstate->return_msg, &qstate->qinfo,\n+\t\t\tqstate->reply_origin, &suspend);\n+\t\t/* If NSEC3 was needed during validation, NULL the NSEC3 cache;\n+\t\t * it will be re-initiated if needed later on.\n+\t\t * Validation (and the cache table) are happening/allocated in\n+\t\t * the super qstate whilst the RRs are allocated (and pointed\n+\t\t * to) in this sub qstate. */\n+\t\tif(vq->nsec3_cache_table.ct) {\n+\t\t\tvq->nsec3_cache_table.ct = NULL;\n+\t\t}\n+\t\tif(suspend) {\n+\t\t\t/* deep copy the return_msg to vq->sub_ds_msg; it will\n+\t\t\t * be resumed later in the super state with the caveat\n+\t\t\t * that the initial calculations will be re-caclulated\n+\t\t\t * and re-suspended there before continuing. */\n+\t\t\tvq->sub_ds_msg = dns_msg_deepcopy_region(\n+\t\t\t\tqstate->return_msg, super->region);\n+\t\t}\n \t\treturn;\n \t} else if(qstate->qinfo.qtype == LDNS_RR_TYPE_DNSKEY) {\n \t\tprocess_dnskey_response(super, vq, id, qstate->return_rcode,\n@@ -3133,8 +3328,8 @@ val_clear(struct module_qstate* qstate, int id)\n \t\treturn;\n \tvq = (struct val_qstate*)qstate->minfo[id];\n \tif(vq) {\n-\t\tif(vq->msg_signatures_timer) {\n-\t\t\tcomm_timer_delete(vq->msg_signatures_timer);\n+\t\tif(vq->suspend_timer) {\n+\t\t\tcomm_timer_delete(vq->suspend_timer);\n \t\t}\n \t}\n \t/* everything is allocated in the region, so assign NULL */"
          },
          {
            "filename": "validator/validator.h",
            "additions": 9,
            "deletions": 4,
            "blob_url": "https://github.com/NLnetLabs/unbound/blob/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c/validator%2Fvalidator.h",
            "diff": "@@ -45,6 +45,7 @@\n #include \"util/module.h\"\n #include \"util/data/msgreply.h\"\n #include \"validator/val_utils.h\"\n+#include \"validator/val_nsec3.h\"\n struct val_anchors;\n struct key_cache;\n struct key_entry_key;\n@@ -221,10 +222,14 @@ struct val_qstate {\n \tint msg_signatures_state;\n \t/** The rrset index for the msg signatures to continue from */\n \tsize_t msg_signatures_index;\n+\t/** Cache table for NSEC3 hashes */\n+\tstruct nsec3_cache_table nsec3_cache_table;\n+\t/** DS message from sub if it got suspended from NSEC3 calculations */\n+\tstruct dns_msg* sub_ds_msg;\n \t/** The timer to resume processing msg signatures */\n-\tstruct comm_timer* msg_signatures_timer;\n-\t/** number of suspends */\n-        int suspend_count;\n+\tstruct comm_timer* suspend_timer;\n+\t/** Number of suspends */\n+\tint suspend_count;\n };\n \n /**\n@@ -273,6 +278,6 @@ void val_clear(struct module_qstate* qstate, int id);\n size_t val_get_mem(struct module_env* env, int id);\n \n /** Timer callback for msg signatures continue timer */\n-void validate_msg_signatures_timer_cb(void* arg);\n+void validate_suspend_timer_cb(void* arg);\n \n #endif /* VALIDATOR_VALIDATOR_H */"
          }
        ]
      },
      "time": "2024-08-04 12:14:27"
    }
  ],
  "ref_links": [
    "https://kb.isc.org/docs/cve-2023-50868",
    "https://downloads.isc.org/isc/bind9/9.16.48/patches/0005-CVE-2023-50387-CVE-2023-50868.patch",
    "https://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2024q1/017430.html",
    "https://www.knot-resolver.cz/2024-02-13-knot-resolver-5.7.1.html",
    "https://github.com/CZ-NIC/knot-resolver/commit/e966b7fdb167add0ec37c56a954c2d847f627985(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/eccb8e278c1cde0548cc570eac619feaa290cede(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/b5051ac26f34358b40f9115f977fe1f54e8f581e(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/24699e9f206a8f957b516cad22a8e5790d226836(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/a05cf1d379d1af0958587bd111f791b72f404364(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/9b421cdf91f987e0254a06ff2c4e8fbf76dc2b58(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/5e80624b18d40ae44be704751d3b22943edf287f",
    "https://github.com/CZ-NIC/knot-resolver/commit/f9ba52e6f54bc1db122870df50cb364cb977436e(v5.7.1)",
    "https://github.com/CZ-NIC/knot-resolver/commit/b044babbee358dc305d770a1dab3a877c49468a7(v5.7.1)",
    "https://blog.powerdns.com/2024/02/13/powerdns-recursor-4-8-6-4-9-3-5-0-2-released",
    "Fixed by:https://github.com/PowerDNS/pdns/pull/13781",
    "https://nlnetlabs.nl/news/2024/Feb/13/unbound-1.19.1-released/",
    "https://nlnetlabs.nl/downloads/unbound/CVE-2023-50387_CVE-2023-50868.txt",
    "Fixed by:https://github.com/NLnetLabs/unbound/commit/92f2a1ca690a44880f4c4fa70a4b5a4b029aaf1c(release-1.19.1)",
    "https://github.com/systemd/systemd/issues/31413",
    "https://github.com/systemd/systemd/commit/67d0ce8843d612a2245d0966197d4f528b911b66(v256)",
    "https://github.com/systemd/systemd/commit/eba291124bc11f03732d1fc468db3bfac069f9cb(v256)",
    "https://github.com/systemd/systemd-stable/commit/1ebdb19ff194120109b08bbf888bdcc502f83211(v255.4)",
    "https://github.com/systemd/systemd-stable/commit/572692f0bdd6a3fabe3dd4a3e8e5565cc69b5e14(v255.4)",
    "https://github.com/systemd/systemd-stable/commit/2f5edffa8ffd5210165ebe7604f07d23f375fe9a(v254.10)",
    "https://github.com/systemd/systemd-stable/commit/9899281c59a91f19c8b39362d203e997d2faf233(v254.10)",
    "https://github.com/systemd/systemd-stable/commit/7886eea2425fe7773cc012da0b2e266e33d4be12(v253.17)",
    "https://github.com/systemd/systemd-stable/commit/156e519d990a5662c719a1cbe80c6a02a2b9115f(v253.17)",
    "https://github.com/systemd/systemd-stable/commit/7633d969f3422f9ad380a512987d398e54764817(v252.23)",
    "https://github.com/systemd/systemd-stable/commit/b43bcb51ebf9aea21b1e280e1872056994e3f53d(v252.23)",
    "https://github.com/advisories/GHSA-mmwx-rj87-vfgr",
    "https://github.com/dnsjava/dnsjava/commit/711af79be3214f52daa5c846b95766dc0a075116(v3.6.0)"
  ],
  "source_url": "https://security-tracker.debian.org/tracker/CVE-2023-50868"
}